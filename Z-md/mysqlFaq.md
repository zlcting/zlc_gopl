# **mysql 相关知识总结**
mysql的常考的知识点主要集中在 索引 事务 隔离级别 锁机制 数据库引擎 等几个方面

### 一.首先，先来看一下索引访问的知识 这也是最重要和面试最常遇到的问题

问题1：你都知道那些索引类型（经常被问到）
如果你这样答：“唯一索引 主键索引 普通索引 复合索引” 不好意思不完全

正确姿势应该是 

从物理存储角度:
 聚簇索引和非聚簇索引
从数据结构角度:
 B+树索引、hash索引、FULLTEXT索引、R-Tree索引
从逻辑角度:
主键索引：主键索引是一种特殊的唯一索引，不允许有空值
普通索引或者单列索引
多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
唯一索引或者非唯一索引
空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。

我们来简单介绍一下各种索引包含的相关知识
#### 1.聚簇索引和非聚簇索引
创建的索引，如复合索引、前缀索引、唯一索引，都是属于非聚簇索引，在有的书籍中，又将其称为辅助索引(secondary index)。在后文中，我们称其为非聚簇索引，其数据结构为B+树。
那么，这个聚簇索引，在Mysql中是没有语句来另外生成的。在Innodb中，Mysql中的数据是按照主键的顺序来存放的。那么聚簇索引就是按照每张表的主键来构造一颗B+树，叶子节点存放的就是整张表的行数据。由于表里的数据只能按照一颗B+树排序，因此一张表只能有一个聚簇索引。
在Innodb中，聚簇索引默认就是主键索引。

ps：如果没有主键，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引 如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引

ps：自增主键和uuid作为主键的区别么？
由于主键使用了聚簇索引，如果主键是自增id，，那么对应的数据一定也是相邻地存放在磁盘上的，写入性能比较高。如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了

#### **2.我们应如何创建索引**
1）索引不是越多越好，冗余的索引不仅会增加磁盘空间，而且还会影响insert update del 等性能
2）少量的数据尽量不使用索引，数据量比较少的时候遍历的时间可能比查询索引的时间还要短
3）在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度
4）在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引。

#### 3.mysql索引是什么结构的？
答 ：B+ Tree

![图片](https://mmbiz.qpic.cn/mmbiz_png/SYoYmIOcI5pNETceKAjvsqX8QNKR8ib9JXJObPtDTOcYYOEM0oQH1krZ6gqcGqT2hoc78RiaSUpvx1JbAPISo5Nw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/SYoYmIOcI5pNETceKAjvsqX8QNKR8ib9JXmvXI7D577A8KVD24sEByOg3gRW5MGh1B00OVoQn0rM0DHdpiazb5tw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1
)
注意一下B+ tree的两个明显特点

数据只出现在叶子节点

所有叶子节点增加了一个链指针

接下来就可以开始编了～～比如数据库索引采用B+ tree的主要原因是B Tree在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+ tree应运而生。B+ tree只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，如果使用B Tree，则需要做局部的中序遍历，可能要跨层访问，效率太慢。

#### 4.联合索引和单列索引（到底为啥联合索引要遵循最左原则）
假设这是一个多列索引(col1, col2,col3)，对于叶子节点，col1表示的是年龄，col2表示的是姓氏，col3表示的是名字。如下图：
联合索引(col1, col2,col3)也是一棵B+Tree，其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。
![图片](https://raw.githubusercontent.com/zlcting/zlc_gopl/master/Z-md/img/Jointindex_structure.png)

如图，联合索引(年龄, 姓氏,名字)，叶节点上data域存储的是三个关键字的数据。且是按照年龄、姓氏、名字的顺序排列的。

因此，如果执行的是：
select * from STUDENT where 姓氏='李' and 名字='安';
或者
select * from STUDENT where 名字='安';
那么当执行查询的时候，是无法使用这个联合索引的。因为联合索引中是先根据年龄进行排序的。如果年龄没有先确定，直接对姓氏和名字进行查询的话，就相当于乱序查询一样，因此索引无法生效。因此查询是全表查询。

如果执行的是：
select * from STUDENT where 年龄=1 and 姓氏='李';
那么当执行查询的时候，索引是能生效的，从图中很直观的看出，age=1的是第一个叶子节点的前6条记录，在age=1的前提下，姓氏=’李’的是前3条。因此最终查询出来的是这三条，从而能获取到对应记录的地址。
如果执行的是：
select * from STUDENT where 年龄=1 and 姓氏='黄' and 名字='安';
那么索引也是生效的。

而如果执行的是：
select * from STUDENT where 年龄=1 and 名字='安';
那么，索引年龄部分能生效，名字部分不能生效。也就是说索引部分生效。

因此我对联合索引结构的理解就是B+Tree是按照第一个关键字进行索引，然后在叶子节点上按照第一个关键字、第二个关键字、第三个关键字…进行排序。

**而之所以会有最左原则，是因为联合索引的B+Tree是按照第一个关键字进行索引排列的**


#### 5.mysql某表建了多个单索引，查询多个条件时如何走索引的？（- -! 还没搞懂 待续）
有兴趣的大家可以看看下面这个链接
https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484489&idx=1&sn=b4078d168dfe86d992a5eca26b1e4f4b&chksm=96f66620a181ef362a285dcfb06dedcc07c4ef93edc6784c3466568e2eb4715ac471467dec42&scene=21#wechat_redirect


## 二 锁机制
参考
https://zhuanlan.zhihu.com/p/65281198

## 1 宏观

### 1.1 数据库锁

- 数据库锁适用于集群
- 粒度小，更方便控制

### 1.2 代码锁

- 需要复杂的处理，才能作用于集群

- 粒度大

## 2 微观

### 2.1 行锁 & 表锁

#### 2.1.1 说明

**只有「明确」指定主键，才会执行锁，否则将会执行表锁**

#### 2.1.2 示例

假设有个表 products ，字段id、name、type，id是主键。

- 无锁

  ```mysql
  # 明确指定主键，但不存在该主键的值(没有数据，当然不会有锁)
  SELECT * FROM products WHERE id=-1 FOR UPDATE;
  ```

- 行锁

  ```mysql
  # 明确指定主键
  SELECT * FROM products WHERE id=3 FOR UPDATE;
  SELECT * FROM products WHERE id=3 AND type=1 FOR UPDATE;
  ```

- 表锁

  ```mysql
  # 主键不明确
  SELECT * FROM products WHERE name='Mouse' FOR UPDATE;
  SELECT * FROM products WHERE id<>'3' FOR UPDATE;
  SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;
  ```

#### 2.1.3 注意

- 要测试锁定的状况，可以利用 MySQL 的 Command Mode ，开二个视窗来做测试。
- MyAsim 只支持表级锁，InnerDB支持行级锁添加了（行级锁、表级锁）锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除） 。是表级锁时，不管是否查询到记录，都会锁定表。

### 2.2 行锁算法

#### 2.2.1 Record Lock（普通行锁）

- 对于键值在条件范围内，且存在的记录，使用" Record Lock "，即普通的行锁机制；

#### 2.2.2 Gap Lock（间隙锁）

- 对于键值在条件范围内但并不存在的记录，叫做" 间隙（GAP) "，InnoDB会对这个“间隙”加锁，这种锁机制就是所谓的" Gap Lock "(间隙锁)；

#### 2.2.3 Next-Key Lock（行 & 间隙）

- 对于存在于不存在的数据同时加锁，则称为" Next-Key Lock "；

- **Next-Key Lock包含Record Lock和Gap Lock；**

  ```sql
  # 假如user表中只有101条记录，empid的值是1,2,...,100,101
  # 范围条件的检索，会对值为101的记录加锁，也会对大于101（不存在）加锁
  # 由于两个锁同时存在，则此处为 Next-Key Lock
  select * from  user where user_id > 100 for update;
  ```

### 2.3 表锁算法

#### 2.3.1 意向锁

- 当一个事务带着表锁去访问一个被加了行锁的资源，那么，此时，这个行锁就会升级为意向锁，将表锁住。

- 常用的意向锁有：意向共享锁，意向排它锁，共享意向排它锁

#### 2.3.2 自增锁

- 事务插入自增类型的列时获取自增锁

  > 如果一个事务正在往表中插入自增记录，所有其他事务的插入必须等待

## 3 实现

### 3.1 共享锁 & 排它锁

> 行锁和表锁是锁粒度的概念，共享锁和排它锁是他们的具体实现

#### 3.1.1 共享锁（S）：读锁

- 允许一个事务去读一行，阻止其他事务获取该行的排它锁。
- 多事务时，只能加共享读锁，不能加排他写锁；单事务时，可以加任何锁。
- 一般理解为：能读，不能写。

#### 3.1.2 排它锁（X）：写锁

- 允许持有排它锁的事务读写数据，阻止其他事物获取该数据的共享锁和排它锁。
- 其他事务不能获取该数据的任何锁，直到排它锁持有者释放。
- 不能获取任何锁，不代表不能无锁读取。

**<font color="red">注意</font>**

- 排它锁指的是，在某个事务获取数据的排它锁后，其他事务不能获取该数据的任何锁，
  **并不代表其他事务不能无锁读取该数据。**
  - <font color="red">无锁</font>
    - **select ... from**
  - <font color="red">共享锁</font>
    - **select ... lock in share mode**
  - <font color="red">排它锁</font>
    - **update**
    - **delete**
    - **insert**
    - **select ... for update**

- MySQL8.0 中，使用 FOR SHARE 替代了 LOCK IN SHARE MODE，但仍然支持 LOCK IN SHARE MODE；
  虽然是等价的，但是 FOR SHARE 支持 NOWAIT 、 SKIP LOCKED 等，配合自旋，可以实现高效的等待队列。



### 3.2 乐观锁 & 悲观锁

> 不管是什么锁都需要增加，需加失败重试

#### 3.2.1 乐观锁

- 通过版本号来进行更新的操作属于乐观锁

  ```sql
  update tab set name = 'xxx' where id = 1 and version = xxx
  ```

#### 3.2.2 悲观锁

> 共享锁 & 排它锁都是悲观锁的具象实现

- 显示地控制行或表锁属于悲观锁



### 4  原理

牵扯到索引巴拉巴拉...


## 三 隔离级别


问：“讲讲mysql有几个事务隔离级别？” 
你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读” 
问：“为什么mysql选可重复读作为默认的隔离级别？” 
(你面露苦色，不知如何回答！) 
问:"你们项目中选了哪个隔离级别？为什么？" 
你：“当然是默认的可重复读，至于原因。。呃。。。” (然后你就可以回去等通知了！)
https://zhuanlan.zhihu.com/p/59061106